---
layout: post
title: JQPL
tags: [Java, JQPL]
color: rgb(250, 154, 133)
feature-img: "assets/img/pexels/design-art/christmas-around-corner.png"
thumbnail: "assets/img/pexels/design-art/christmas-around-corner.png"
author: QubitPi
excerpt_separator: <!--more-->
---

The Java Persistence Query Language (JPQL) is a platform-independent object-oriented query language defined by JPA. JPQL
is similar to SQL, but operates on objects, attributes and relationships instead of tables and columns.

<!--more-->

* TOC
{:toc}

The Java Persistence query language (JPQL) is used to define searches against persistent entities independent of the
mechanism used to store those entities. As such, JPQL is "portable", and not constrained to any particular data store.
The Java Persistence query language is an extension of the Enterprise JavaBeans query language, EJB QL, adding
operations such as bulk deletes and updates, join operations, aggregates, projections, and subqueries. Furthermore, JPQL
queries can be declared statically in metadata, or can be dynamically built in code

## JPQL Statement Types

A JPQL statement may be

1. a `SELECT` statement, or
2. an `UPDATE` statement,
3. or a `DELETE` statement

In BNF syntax, a query language statement is defined as:

```
QL_statement ::= select_statement | update_statement | delete_statement
```

### JPQL Select Statement

A select statement is a string which consists of the following clauses:

* a `SELECT` clause, which determines the type of the objects or values to be selected;
* a `FROM` clause, which provides declarations that designate the domain to which the expressions specified in the other
  clauses of the query apply;
* an *optional* `WHERE` clause, which may be used to restrict the results that are returned by the query;
* an *optional* `GROUP BY` clause, which allows query results to be aggregated in terms of groups;
* an *optional* `HAVING` clause, which allows filtering over aggregated groups;
* an *optional* `ORDER BY` clause, which may be used to order the results that are returned by the query.

In BNF syntax, a select statement is defined as:

```
select_statement ::= select_clause from_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause]
```

### JPQL Update and Delete Statements

Update and delete statements provide bulk operations over sets of entities. In BNF syntax, these operations are defined
as:

```
update_statement ::= update_clause [where_clause]
delete_statement ::= delete_clause [where_clause
```

## JPQL Abstract Schema Types and Query Domains

The Java Persistence query language is a typed language, and every expression has a type. The type of an expression is
derived from the structure of the expression, the abstract schema types of the identification variable declarations, the
types to which the persistent fields and relationships evaluate, and the types of literals. The abstract schema type of
an entity is derived from the entity class and the metadata information provided by Java language annotations or in the
XML descriptor.

Informally, the abstract schema type of an entity can be characterized as follows:

* For every persistent field or get accessor method (for a persistent property) of the entity class, there is a field
  ("state-field") whose abstract schema type corresponds to that of the field or the result type of the accessor method.
* For every persistent relationship field or get accessor method (for a persistent relationship property) of the entity
  class, there is a field ("association-field") whose type is the abstract schema type of the related entity (or, if the
  relationship is a one-to-many or many-to-many, a collection of such). Abstract schema types are specific to the query
  language data model. **The persistence provider is not required to implement or otherwise materialize an abstract
  schema type**. The domain of a query consists of the abstract schema types of all entities that are defined in the
  same persistence unit. The domain of a query may be restricted by the navigability of the relationships of the entity
  on which it is based. The association-fields of an entity's abstract schema type determine navigability. Using the
  association-fields and their values, a query can select related entities and use their abstract schema types in the
  query.

### JPQL Entity Naming

Entities are designated in query strings by their entity names. The entity name is defined by the name element of the
Entity annotation (or the entity-name XML descriptor element), and defaults to the unqualified name of the entity class.
Entity names are scoped within the persistence unit and must be unique within the persistence unit.

### JPQL Schema Example

This example assumes that the application developer provides several entity classes representing magazines, publishers,
authors, and articles. The abstract schema types for these entities are `Magazine`, `Publisher`, `Author`, and
`Article`.

The entity `Publisher` has a one-to-many relationships with `Magazine`. There is also a one-to-many relationship between
`Magazine` and `Article`. The entity `Article` is related to `Author` in a one-to-one relationship.

Queries to select magazines can be defined by navigating over the association-fields and state-fields defined by
`Magazine` and `Author`. A query to find all magazines that have unpublished articles is as follows:

```sql
SELECT DISTINCT mag
FROM Magazine AS mag
JOIN mag.articles AS art
WHERE art.published = FALSE
```

The next query navigates over the association-field authors of the abstract schema type `Magazine` to find articles, and
uses the state-field `published` of `Article` to select those magazines that have at least one article that is
published. Although predefined reserved identifiers, such as `DISTINCT`, `FROM`, `AS`, `JOIN`, `WHERE`, and `FALSE`,
appear in upper case in this example, predefined reserved identifiers are case insensitive. The `SELECT` clause of this
example designates the return type of this query to be of type `Magazine`. Because the same persistence unit defines the
abstract persistence schemas of the related entities, the developer can also specify a query over `articles` that
utilizes the abstract schema type for products, and hence the state-fields and association-fields of both the abstract
schema types `Magazine` and `Author`. For example, if the abstract schema type `Author` has a state-field named
`firstName`, a query over `articles` can be specified using this state-field. Such a query might be to find all
magazines that have articles authored by someone with the first name "John".

```sql
SELECT DISTINCT mag
FROM Magazine mag
JOIN mag.articles art JOIN art.author auth WHERE auth.firstName = 'John'
```

Because `Magazine` is related to `Author` by means of the relationships between `Magazine` and `Article` and between
`Article` and `Author`, navigation using the association-fields authors and product is used to express the query. This
query is specified by using the abstract schema name `Magazine`, which designates the abstract schema type over which
the query ranges. The basis for the navigation is provided by the association-fields authors and product of the abstract
schema types `Magazine` and `Article` respectively.

## JPQL FROM Clause and Navigational Declarations

