---
layout: post
title: JQPL
tags: [Java, JQPL]
color: rgb(250, 154, 133)
feature-img: "assets/img/pexels/design-art/christmas-around-corner.png"
thumbnail: "assets/img/pexels/design-art/christmas-around-corner.png"
author: QubitPi
excerpt_separator: <!--more-->
---

The Java Persistence Query Language (JPQL) is a platform-independent object-oriented query language defined by JPA. JPQL
is similar to SQL, but operates on objects, attributes and relationships instead of tables and columns.

<!--more-->

* TOC
{:toc}

The Java Persistence query language (JPQL) is used to define searches against persistent entities independent of the
mechanism used to store those entities. As such, JPQL is "portable", and not constrained to any particular data store.
The Java Persistence query language is an extension of the Enterprise JavaBeans query language, EJB QL, adding
operations such as bulk deletes and updates, join operations, aggregates, projections, and subqueries. Furthermore, JPQL
queries can be declared statically in metadata, or can be dynamically built in code

## JPQL Statement Types

A JPQL statement may be

1. a `SELECT` statement, or
2. an `UPDATE` statement,
3. or a `DELETE` statement

In BNF syntax, a query language statement is defined as:

```
QL_statement ::= select_statement | update_statement | delete_statement
```

### JPQL Select Statement

A select statement is a string which consists of the following clauses:

* a `SELECT` clause, which determines the type of the objects or values to be selected;
* a `FROM` clause, which provides declarations that designate the domain to which the expressions specified in the other
  clauses of the query apply;
* an *optional* `WHERE` clause, which may be used to restrict the results that are returned by the query;
* an *optional* `GROUP BY` clause, which allows query results to be aggregated in terms of groups;
* an *optional* `HAVING` clause, which allows filtering over aggregated groups;
* an *optional* `ORDER BY` clause, which may be used to order the results that are returned by the query.

In BNF syntax, a select statement is defined as:

```
select_statement ::= select_clause from_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause]
```

### JPQL Update and Delete Statements

Update and delete statements provide bulk operations over sets of entities. In BNF syntax, these operations are defined
as:

```
update_statement ::= update_clause [where_clause]
delete_statement ::= delete_clause [where_clause
```

## JPQL Abstract Schema Types and Query Domains

The Java Persistence query language is a typed language, and every expression has a type. The type of an expression is
derived from the structure of the expression, the abstract schema types of the identification variable declarations, the
types to which the persistent fields and relationships evaluate, and the types of literals. The abstract schema type of
an entity is derived from the entity class and the metadata information provided by Java language annotations or in the
XML descriptor.

Informally, the abstract schema type of an entity can be characterized as follows:

* For every persistent field or get accessor method (for a persistent property) of the entity class, there is a field
  ("state-field") whose abstract schema type corresponds to that of the field or the result type of the accessor method.
* For every persistent relationship field or get accessor method (for a persistent relationship property) of the entity
  class, there is a field ("association-field") whose type is the abstract schema type of the related entity (or, if the
  relationship is a one-to-many or many-to-many, a collection of such). Abstract schema types are specific to the query
  language data model. **The persistence provider is not required to implement or otherwise materialize an abstract
  schema type**. The domain of a query consists of the abstract schema types of all entities that are defined in the
  same persistence unit. The domain of a query may be restricted by the navigability of the relationships of the entity
  on which it is based. The association-fields of an entity's abstract schema type determine navigability. Using the
  association-fields and their values, a query can select related entities and use their abstract schema types in the
  query.

### JPQL Entity Naming

Entities are designated in query strings by their entity names. The entity name is defined by the name element of the
Entity annotation (or the entity-name XML descriptor element), and defaults to the unqualified name of the entity class.
Entity names are scoped within the persistence unit and must be unique within the persistence unit.

### JPQL Schema Example

This example assumes that the application developer provides several entity classes representing magazines, publishers,
authors, and articles. The abstract schema types for these entities are `Magazine`, `Publisher`, `Author`, and
`Article`.

The entity `Publisher` has a one-to-many relationships with `Magazine`. There is also a one-to-many relationship between
`Magazine` and `Article`. The entity `Article` is related to `Author` in a one-to-one relationship.

Queries to select magazines can be defined by navigating over the association-fields and state-fields defined by
`Magazine` and `Author`. A query to find all magazines that have unpublished articles is as follows:

```sql
SELECT DISTINCT mag
FROM Magazine AS mag
JOIN mag.articles AS art
WHERE art.published = FALSE
```

The next query navigates over the association-field authors of the abstract schema type `Magazine` to find articles, and
uses the state-field `published` of `Article` to select those magazines that have at least one article that is
published. Although predefined reserved identifiers, such as `DISTINCT`, `FROM`, `AS`, `JOIN`, `WHERE`, and `FALSE`,
appear in upper case in this example, predefined reserved identifiers are case insensitive. The `SELECT` clause of this
example designates the return type of this query to be of type `Magazine`. Because the same persistence unit defines the
abstract persistence schemas of the related entities, the developer can also specify a query over `articles` that
utilizes the abstract schema type for products, and hence the state-fields and association-fields of both the abstract
schema types `Magazine` and `Author`. For example, if the abstract schema type `Author` has a state-field named
`firstName`, a query over `articles` can be specified using this state-field. Such a query might be to find all
magazines that have articles authored by someone with the first name "John".

```sql
SELECT DISTINCT mag
FROM Magazine mag
JOIN mag.articles art JOIN art.author auth WHERE auth.firstName = 'John'
```

Because `Magazine` is related to `Author` by means of the relationships between `Magazine` and `Article` and between
`Article` and `Author`, navigation using the association-fields authors and product is used to express the query. This
query is specified by using the abstract schema name `Magazine`, which designates the abstract schema type over which
the query ranges. The basis for the navigation is provided by the association-fields authors and product of the abstract
schema types `Magazine` and `Article` respectively.

## JPQL FROM Clause and Navigational Declarations

The `FROM` clause of a query defines the domain of the query by declaring identification variables. An identification
variable is an identifier declared in the `FROM` clause of a query. The domain of the query may be constrained by path
expressions. Identification variables designate instances of a particular entity abstract schema type. The `FROM` clause
can contain multiple identification variable declarations separated by a comma (,):

* `from_clause ::= FROM identification_variable_declaration {, {identification_variable_declaration | collection_member_declaration}}*`
* `identification_variable_declaration ::= range_variable_declaration { join | fetch_join }*`
* `range_variable_declaration ::= abstract_schema_name [AS] identification_variable`
* `join ::= join_spec join_association_path_expression [AS] identification_variable`
* `fetch_join ::= join_spec FETCH join_association_path_expression`
* `join_association_path_expression ::= join_collection_valued_path_expression | join_single_valued_association_path_expression`
* `join_spec ::= [ LEFT [OUTER] | INNER ] JOIN`
* `collection_member_declaration ::= IN (collection_valued_path_expression) [AS] identification_variable`

### JPQL FROM Identifiers

An identifier is a character sequence of unlimited length. **The character sequence must begin with a Java identifier**
start character, and all other characters must be Java identifier part characters. An identifier start character is any
character for which the method `Character.isJavaIdentifierStart` returns `true`. This includes the underscore (`_`)
character and the dollar-sign (`$`) character. An identifier-part character is any character for which the method
`Character.isJavaIdentifierPart` returns true . The question-mark (`?`) character is reserved for use by the Java
Persistence query language. The following are reserved identifiers:

* `SELECT`
* `FROM`
* `WHERE`
* `UPDATE`
* `DELETE`
* `JOIN`
* `OUTER`
* `INNER`
* `LEFT`
* `GROUP`
* `BY`
* `HAVING`
* `FETCH`
* `DISTINCT`
* `OBJECT`
* `NULL`
* `TRUE`
* `FALSE`
* `NOT`
* `AND`
* `OR`
* `BETWEEN`
* `LIKE`
* `IN`
* `AS`
* `UNKNOWN`
* `EMPTY`
* `MEMBER`
* `OF`
* `IS`
* `AVG`
* `MAX`
* `MIN`
* `SUM`
* `COUNT`
* `ORDER`
* `BY`
* `ASC`
* `DESC`
* `MOD`
* `UPPER`
* `LOWER`
* `TRIM`
* `POSITION`
* `CHARACTER_LENGTH`
* `CHAR_LENGTH`
* `BIT_LENGTH`
* `CURRENT_TIME`
* `CURRENT_DATE`
* `CURRENT_TIMESTAMP`
* `NEW`
* `EXISTS`
* `ALL`
* `ANY`
* `SOME`

Reserved identifiers are case insensitive. Reserved identifiers must not be used as identification variables. It is
recommended that other SQL reserved words not be used as identification variables in queries, as they may be used as
reserved identifiers in future releases of the specification.

### JPQL Identification Variables

An identification variable is a valid identifier declared in the `FROM` clause of a query. All identification variables
must be declared in the `FROM` clause. Identification variables cannot be declared in other clauses. An identification
variable must not be a reserved identifier or have the same name as any entity in the same persistence unit:
Identification variables are case insensitive. An identification variable evaluates to a value of the type of the
expression used in declaring the variable. For example, consider the previous query:

```sql
SELECT DISTINCT mag
FROM Magazine mag JOIN mag.articles art JOIN art.author auth
WHERE auth.firstName = 'John'
```

In the `FROM` clause declaration `mag.articles art`, the identification variable `art` evaluates to any `Article` value
directly reachable from `Magazine`. The association-field articles is a collection of instances of the abstract schema
type `Article` and the identification variable `art` refers to an element of this collection. The type of `auth` is the
abstract schema type of `Author`. An identification variable ranges over the abstract schema type of an entity. An
identification variable designates an instance of an entity abstract schema type or an element of a collection of entity
abstract schema type instances. Identification variables are existentially quantified in a query. An identification
variable always designates a reference to a single value. It is declared in one of three ways:

1. in a range variable declaration,
2. in a join clause, or
3. in a collection member declaration.

The identification variable declarations are evaluated from left to right in the `FROM` clause, and an identification
variable declaration can use the result of a preceding identification variable declaration of the query string.

### JPQL Range Declarations

The syntax for declaring an identification variable as a range variable is similar to that of SQL; optionally, it uses
the `AS` keyword:

```
range_variable_declaration ::= abstract_schema_name [AS] identification_variable
```

Range variable declarations allow the developer to designate a "root" for objects which may not be reachable by
navigation. In order to select values by comparing more than one instance of an entity abstract schema type, more than
one identification variable ranging over the abstract schema type is needed in the `FROM` clause.

The following query returns magazines whose prices are greater than the price of magazines published by "Adventure"
publishers. This example illustrates the use of two different identification variables in the `FROM` clause, both of the
abstract schema type `Magazine`. The `SELECT` clause of this query determines that it is the magazines with prices
greater than those of "Adventure" publisher's that are returned.

```sql
SELECT DISTINCT mag1
FROM Magazine mag1, Magazine mag2
WHERE mag1.price > mag2.price AND mag2.publisher.name = 'Adventure'
```

### JPQL Path Expressions

**An identification variable followed by the navigation operator (.) and a state-field or association-field is a path
expression.** The type of the path expression is the type computed as the result of navigation; that is, the type of the
state-field or association-field to which the expression navigates. Depending on navigability, a path expression that
leads to an association-field may be further composed. Path expressions can be composed from other path expressions if
the original path expression evaluates to a single-valued type (not a collection) corresponding to an association-field.
**Path-expression navigability is composed using "inner join" semantics. That is, if the value of a non-terminal
association-field in the path expression is `null`, the path is considered to have no value, and does not participate in
the determination of the result**. The syntax for single-valued path expressions and collection-valued path expressions
is as follows:

* `single_valued_path_expression ::= state_field_path_expression | single_valued_association_path_expression`
* `state_field_path_expression ::= {identification_variable | single_valued_association_path_expression}.state_field`
* `single_valued_association_path_expression ::= identification_variable.{single_valued_association_field.}*single_valued_association_field`
* `collection_valued_path_expression ::= identification_variable.{single_valued_association_field.}*collection_valued_association_field`
* `state_field ::= {embedded_class_state_field.}*simple_state_field`

A single_valued_association_field is designated by the name of an association-field in a one-to-one or many-to-one
relationship. The type of a single_valued_association_field and thus a single_valued_association_path_expression is the
abstract schema type of the related entity. A collection_valued_association_field is designated by the name of an
association-field in a one-to-many or a many-to-many relationship. The type of a collection_valued_association_field is
a collection of values of the abstract schema type of the related entity. An embedded_class_state_field is designated
by the name of an entity-state field that corresponds to an embedded class. Navigation to a related entity results in a
value of the related entity's abstract schema type.

The evaluation of a path expression terminating in a state-field results in the abstract schema type corresponding to 
the Java type designated by the state-field. It is syntactically illegal to compose a path expression from a path
expression that evaluates to a collection. For example, if `mag` designates `Magazine`, the path expression
`mag.articles.author` is illegal since navigation to authors results in a collection. This case should produce an error
when the query string is verified. To handle such a navigation, an identification variable must be declared in the
`FROM` clause to range over the elements of the articles collection. Another path expression must be used to navigate
over each such element in the `WHERE` clause of the query, as in the following query, which returns all authors that
have any articles in any magazines:

```sql
SELECT DISTINCT art.author
FROM Magazine AS mag, IN(mag.articles) art
```

### JPQL Joins

**An [inner join](https://www.w3schools.com/sql/sql_join_inner.asp) may be implicitly specified by the use of a 
artesian product in the FROM clause and a join condition in the `WHERE` clause**.

The syntax for explicit join operations is as follows:

* `join ::= join_spec join_association_path_expression [AS] identification_variable`
* `fetch_join ::= join_spec FETCH join_association_path_expression`
* `join_spec ::= [ LEFT [OUTER] | INNER ] JOIN`
* `join_association_path_expression ::= join_collection_valued_path_expression | join_single_valued_association_path_expression`

The following inner and outer join operation types are supported.

#### JPQL Inner Joins (Relationship Joins)

The syntax for the inner join operation is

```sql
[ INNER ] JOIN join_association_path_expression [AS] identification_variable
```

For example, the query below joins over the relationship between publishers and magazines. This type of join typically
equates to a join over a foreign key relationship in the database.

```sql
SELECT pub
FROM Publisher pub JOIN pub.magazines mag
WHERE pub.revenue > 1000000
```

The keyword INNER may optionally be used:

```sql
SELECT pub
FROM Publisher pub INNER JOIN pub.magazines mag
WHERE pub.revenue > 1000000
```

This is equivalent to the following query using the earlier `IN` construct. It selects those publishers with revenue of
over 1 million for which at least one magazine exists:

```sql
SELECT OBJECT(pub)
FROM Publisher pub, IN(pub.magazines) mag
WHERE pub.revenue > 1000000
```

#### JPQL Outer Joins

[`LEFT JOIN` and `LEFT OUTER JOIN` are synonymous](https://www.w3schools.com/sql/sql_join_left.asp). They enable the
retrieval of a set of entities where matching values in the join condition may be absent. The syntax for a left outer
join is

```sql
LEFT [OUTER] JOIN join_association_path_expression [AS] identification_variable
```

For example:

```sql
SELECT pub
FROM Publisher pub LEFT JOIN pub.magazines mag
WHERE pub.revenue > 1000000
```

The keyword `OUTER` may optionally be used:

```sql
SELECT pub
FROM Publisher pub LEFT OUTER JOIN pub.magazines mags
WHERE pub.revenue > 1000000
```

**An important use case for `LEFT JOIN` is in enabling the prefetching of related data items as a side effect of a
query. This is accomplished by specifying the `LEFT JOIN` as a `FETCH JOIN`**.

#### JPQL Fetch Joins

A `FETCH JOIN` enables the fetching of an association as a side effect of the execution of a query. A `FETCH JOIN` is
specified over an entity and its related entities. The syntax for a fetch join is

```sql
fetch_join ::= [ LEFT [OUTER] | INNER ] JOIN FETCH join_association_path_expression
```

The association referenced by the right side of the `FETCH JOIN` clause must be an association that belongs to an entity
that is returned as a result of the query. It is not permitted to specify an identification variable for the entities
referenced by the right side of the `FETCH JOIN` clause, and hence references to the implicitly fetched entities cannot
appear elsewhere in the query. The following query returns a set of magazines. As a side effect, the associated articles
for those magazines are also retrieved, even though they are not part of the explicit query result. The persistent
fields or properties of the articles that are eagerly fetched are fully initialized. The initialization of the
relationship properties of the articles that are retrieved is determined by the metadata for the `Article` entity class.

```sql
SELECT mag
FROM Magazine mag LEFT JOIN FETCH mag.articles
WHERE mag.id = 1
```

A fetch join has the same join semantics as the corresponding inner or outer join, except that the related objects
specified on the right-hand side of the join operation are not returned in the query result or otherwise referenced in
the query. Hence, for example, if magazine id 1 has five articles, the above query returns five references to the
magazine 1 entity.

### JPQL Collection Member Declarations

An identification variable declared by a `collection_member_declaration` ranges over values of a collection obtained by
navigation using a path expression. Such a path expression represents a navigation involving the association-fields of
an entity abstract schema type. Because a path expression can be based on another path expression, the navigation can
use the association-fields of related entities. An identification variable of a collection member declaration is
declared using a special operator, the reserved identifier `IN`. The argument to the `IN` operator is a
collection-valued path expression. The path expression evaluates to a collection type specified as a result of
navigation to a collection-valued association-field of an entity abstract schema type. The syntax for declaring a
collection member identification variable is as follows:

```sql
collection_member_declaration ::= IN (collection_valued_path_expression) [AS] identification_variable
```

For example, the query

```sql
SELECT DISTINCT mag
FROM Magazine mag
    JOIN mag.articles art
    JOIN art.author auth
WHERE auth.lastName = 'Grisham'
```

may equivalently be expressed as follows, using the IN operator:

```sql
SELECT DISTINCT mag
FROM Magazine mag, IN(mag.articles) art
WHERE art.author.lastName = 'Grisham'
```

In this example, articles is the name of an association-field whose value is a collection of instances of the abstract
schema type `Article`. The identification variable `art` designates a member of this collection, a single `Article`
abstract schema type instance. In this example, mag is an identification variable of the abstract schema type
`Magazine`.

### JPQL Polymorphism

Java Persistence queries are automatically polymorphic. The `FROM` clause of a query designates not only instances of
the specific entity classes to which the query explicitly refers but of subclasses as well. The instances returned by a
query include instances of the subclasses that satisfy the query criteria.

## JPQL `WHERE` Clause

The `WHERE` clause of a query consists of a conditional expression used to select objects or values that satisfy the
expression. The `WHERE` clause restricts the result of a select statement or the scope of an update or delete operation.
A `WHERE` clause is defined as follows:

```sql
where_clause ::= WHERE conditional_expression
```

The `GROUP BY` construct enables the aggregation of values according to the properties of an entity class. The `HAVING`
construct enables conditions to be specified that further restrict the query result as restrictions upon the groups. The
syntax of the `HAVING` clause is as follows:

```sql
having_clause ::= HAVING conditional_expression
```

### JPQL Conditional Expressions

The following sections describe the language constructs that can be used in a conditional expression of the `WHERE`
clause or `HAVING` clause. State-fields that are mapped in serialized form or as lobs may not be portably used in
conditional expressions

> The implementation is not expected to perform such query operations involving such fields in memory rather than in the
> database.

#### JPQL Literals

A string literal is enclosed in single quotes -- for example: 'literal'. A string literal that includes a single quote
is represented by two single quotes -- for example: 'literal''s'. String literals in queries, like Java String literals,
use unicode character encoding. The use of Java escape notation is not supported in query string literals. Exact numeric
literals support the use of Java integer literal syntax as well as SQL exact numeric literal syntax. Approximate
literals support the use Java floating point literal syntax as well as SQL approximate numeric literal syntax. Enum
literals support the use of Java enum literal syntax. **The enum class name must be specified**. Appropriate suffixes
may be used to indicate the specific type of a numeric literal in accordance with the Java Language Specification. The
boolean literals are TRUE and FALSE. Although predefined reserved literals appear in upper case, they are case
insensitive.

#### JPQL Identification Variables

All identification variables used in the `WHERE` or `HAVING` clause of a `SELECT` or `DELETE` statement must be declared
in the `FROM` clause, as described in [JPQL Identification Variables](#jpql-identification-variables). The
identification variables used in the `WHERE` clause of an `UPDATE` statement must be declared in the `UPDATE` clause.
Identification variables are existentially quantified in the `WHERE` and `HAVING` clause. This means that an
identification variable represents a member of a collection or an instance of an entity's abstract schema type. An
identification variable never designates a collection in its entirety.

#### JPQL Path Expressions

It is illegal to use a `collection_valued_path_expression` within a `WHERE` or `HAVING` clause as part of a conditional
expression except in an `empty_collection_comparison_expression`, in a `collection_member_expression`, or as an argument
to the `SIZE` operator.

#### JPQL Input Parameters

Either positional or named parameters may be used. Positional and named parameters may not be mixed in a single query.
**Input parameters can only be used in the `WHERE` clause or `HAVING` clause of a query**.

##### JPQL Positional Parameters

The following rules apply to positional parameters.

* Input parameters are designated by the question mark (`?`) prefix followed by an integer. For example: `?1`.
* Input parameters are numbered starting from 1. Note that the same parameter can be used more than once in the query
  string and that the ordering of the use of parameters within the query string need not conform to the order of the
  positional parameters.
  
##### JPQL Named Parameters

A named parameter is an identifier that is prefixed by the ":" symbol. It follows the rules for identifiers defined in
[JPQL FROM Identifiers](#jpql-from-identifiers). Named parameters are case sensitive.

```sql
SELECT pub
FROM Publisher pub
WHERE pub.revenue > :rev
```

#### JPQL Conditional Expression Composition

Conditional expressions are composed of other conditional expressions, comparison operations, logical operations, path
expressions that evaluate to boolean values, boolean literals, and boolean input parameters. Arithmetic expressions can
be used in comparison expressions. Arithmetic expressions are composed of other arithmetic expressions, arithmetic
operations, path expressions that evaluate to numeric values, numeric literals, and numeric input parameters. Arithmetic
operations use numeric promotion. Standard bracketing () for ordering expression evaluation is supported. Conditional
expressions are defined as follows:

* `conditional_expression ::= conditional_term | conditional_expression OR conditional_term`
* `conditional_term ::= conditional_factor | conditional_term AND conditional_factor`
* `conditional_factor ::= [ NOT ] conditional_primary`
* `conditional_primary ::= simple_cond_expression | (conditional_expression)`
* `simple_cond_expression ::= comparison_expression | between_expression | like_expression | in_expression | null_comparison_expression | empty_collection_comparison_expression | collection_member_expression | exists_expression`

Aggregate functions can only be used in conditional expressions in a HAVING clause.

#### JPQL Operators and Operator Precedence

The operators are listed below in order of decreasing precedence.

* Navigation operator (.)
* Arithmetic operators: +, - unary *, / multiplication and division +, - addition and subtraction
* Comparison operators : =, >, >=, <, <=, <> (not equal), [NOT] BETWEEN, [NOT] LIKE, [NOT] IN, IS [NOT] NULL, IS [NOT] EMPTY, [NOT] MEMBER [OF]
* Logical operators: NOT AND OR

The following sections describe other operators used in specific expressions.

#### JPQL Between Expressions

The syntax for the use of the comparison operator `[NOT] BETWEEN` in a conditional expression is as follows:

* `arithmetic_expression [NOT] BETWEEN arithmetic_expression AND arithmetic_expression | string_expression [NOT] BETWEEN string_expression AND string_expression | datetime_expression [NOT] BETWEEN datetime_expression AND datetime_expression`

The BETWEEN expression `x BETWEEN y AND z` is semantically equivalent to `y <= x AND x <= z`, 

#### JPQL In Expressions

The syntax for the use of the comparison operator `[NOT] IN` in a conditional expression is as follows:

* `in_expression ::= state_field_path_expression [NOT] IN ( in_item {, in_item}* | subquery)`
* `in_item ::= literal | input_parameter`

The `state_field_path_expression` must have a

* string,
* numeric, or
* enum value.

The literal and/or input_parameter values must be like the same abstract schema type of the
`state_field_path_expression` in type. The results of the subquery must be like the same abstract schema type of the
`state_field_path_expression` in type. For example,, `o.country IN ('UK', 'US', 'France')`

#### JPQL Like Expressions

The syntax for the use of the comparison operator `[NOT] LIKE` in a conditional expression is as follows:

```
string_expression [NOT] LIKE pattern_value [ESCAPE escape_character]
```

**The `string_expression` must have a string value**. The `pattern_value` is a string literal or a string-valued input
parameter in which an underscore (`_`) stands for any single character, a percent (`%`) character stands for any
sequence of characters (including the empty sequence), and all other characters stand for themselves. The optional
`escape_character` is a single-character string literal or a character-valued input parameter (i.e., char or Character)
and is used to escape the special meaning of the underscore and percent characters in pattern_value. Examples are:

* `asentence.word LIKE 'l_se'` - is true for 'lose' and false for 'loose'
* `aword.underscored LIKE '\_%' ESCAPE '\'` - is true for '_foo' and false for 'bar'

#### JPQL Null Comparison Expressions

The syntax for the use of the comparison operator `IS NULL` in a conditional expression is as follows:

```
{single_valued_path_expression | input_parameter } IS [NOT] NULL
```

A null comparison expression tests whether or not the single-valued path expression or input parameter is a `NULL`
value.

#### JPQL Empty Collection Comparison Expressions

The syntax for the use of the comparison operator `IS EMPTY` in an `empty_collection_comparison_expression` is as follows:

* `collection_valued_path_expression IS [NOT] EMPTY`

This expression tests whether or not the collection designated by the collection-valued path expression is empty (i.e,
has no elements).

For example, the following query will return all magazines that don't have any articles at all:

```sql
SELECT mag
FROM Magazine mag
WHERE mag.articles IS EMPTY
```

If the value of the collection-valued path expression in an empty collection comparison expression is unknown, the value
of the empty comparison expression is unknown.

#### JPQL Collection Member Expressions

The use of the comparison `collection_member_expression` is as follows: syntax for the operator MEMBER OF in an

* `collection_member_expression ::= entity_expression [NOT] MEMBER [OF] collection_valued_path_expression`
* `entity_expression ::= single_valued_association_path_expression | simple_entity_expression`
* `simple_entity_expression ::= identification_variable | input_parameter`

This expression tests whether the designated value is a member of the collection specified by the collection-valued path
expression. If the collection valued path expression designates an empty collection, the value of the `MEMBER OF`
expression is `FALSE` and the value of the `NOT MEMBER OF` expression is `TRUE`. Otherwise, if the value of the
collection-valued path expression or single-valued association-field path expression in the collection member expression
is `NULL` or unknown, the value of the collection member expression is unknown.

#### JPQL Exists Expressions

An `EXISTS` expression is a predicate that is true only if the result of the subquery consists of one or more values and
that is false otherwise. The syntax of an exists expression is

* `exists_expression ::= [NOT] EXISTS (subquery)`

The use of the reserved word `OF` is optional in this expression.

#### JPQL All or Any Expressions

An ALL conditional expression is a predicate that is true if the comparison operation is true for all values in the
result of the subquery or **the result of the subquery is empty**. An ALL conditional expression is false if the result
of the comparison is false for at least one row, and is unknown if neither true nor false. An ANY conditional expression
is a predicate that is true if the comparison operation is true for some value in the result of the subquery. An ANY
conditional expression is false **if the result of the subquery is empty** or if the comparison operation is false for
every value in the result of the subquery, and is unknown if neither true nor false. **The keyword SOME is synonymous
with ANY**. The comparison operators used with ALL or ANY conditional expressions are =, <, <=, >, >=, <>. The result of
the subquery must be like that of the other argument to the comparison operator in type.

```
all_or_any_expression ::= { ALL | ANY | SOME} (subquery)
```

The following example select the authors who make the highest salary for their magazine:

```sql
SELECT auth
FROM Author auth 
WHERE auth.salary >= ALL(SELECT a.salary FROM Author a WHERE a.magazine = auth.magazine)
```

#### JPQL Subqueries

Subqueries may be used in the `WHERE` or `HAVING` clause. The syntax for subqueries is as follows:

* `subquery ::= simple_select_clause subquery_from_clause [where_clause] [groupby_clause] [having_clause]`
* Subqueries are restricted to the WHERE and HAVING clauses in this release. Support for subqueries in the FROM clause will be considered in a later release of the specification.
* `simple_select_clause ::= SELECT [DISTINCT] simple_select_expression`
* `subquery_from_clause ::= FROM subselect_identification_variable_declaration {, subselect_identification_variable_declaration}*`
* `subselect_identification_variable_declaration ::= identification_variable_declaration | association_path_expression [AS] identification_variable | collection_member_declaration`
* `simple_select_expression ::= single_valued_path_expression | aggregate_expression | identification_variable`

Examples:

```sql
SELECT DISTINCT auth
FROM Author auth
WHERE EXISTS (
    SELECT spouseAuth
    FROM Author spouseAuth
    WHERE spouseAuth = auth.spouse
)
```

```sql
SELECT mag
FROM Magazine mag
WHERE (SELECT COUNT(art) FROM mag.articles art) > 10
```

#### JPQL Functional Expressions

The JPQL includes the following built-in functions, which may be used in the `WHERE` or `HAVING` clause of a query. If
the value of any argument to a functional expression is null or unknown, the value of the functional expression is
unknown.

##### JPQL String Functions

* `functions_returning_strings ::= CONCAT(string_primar y, string_primary) | SUBSTRING(string_primar y, simple_arithmetic_expression, simple_arithmetic_expression) | TRIM([[trim_specification] [trim_character] FROM] string_primary) | LOWER(string_primar y) | UPPER(string_primar y)`
* `trim_specification ::= LEADING | TRAILING | BOTH`
* `functions_returning_numerics ::= LENGTH(string_primar y) | LOCATE(string_primar y, string_primar y[, simple_arithmetic_expression])`

The `CONCAT` function returns a string that is a concatenation of its arguments. The second and third arguments of the
`SUBSTRING` function denote the starting position and length of the substring to be returned. These arguments are
integers. The first position of a string is denoted by 1. The `SUBSTRING` function returns a string. The `TRIM` function
trims the specified character from a string. If the character to be trimmed is not specified, it is assumed to be space
(or blank). The optional `trim_character` is a single-character string literal or a character-valued input parameter
(i.e., char or Character). If a trim specification is not provided, BOTH is assumed. The `TRIM` function returns the
trimmed string. The `LOWER` and `UPPER` functions convert a string to lower and upper case, respectively. They return a
string. The `LOCATE` function returns the position of a given string within a string, starting the search at a specified
position. It returns the first position at which the string was found as an integer. The first argument is the string to
be located; the second argument is the string to be searched; the optional third argument is an integer that represents
the string position at which the search is started (by default, the beginning of the string to be searched). The first
position in a string is denoted by 1. If the string is not found, 0 is returned. The `LENGTH` function returns the
length of the string in characters as an integer.

##### JPQL Arithmetic Functions

```
functions_returning_numerics ::= ABS(simple_arithmetic_expression) | SQRT(simple_arithmetic_expression) | MOD(simple_arithmetic_expression, simple_arithmetic_expression) | SIZE(collection_valued_path_expression)
```

The `ABS` function takes a numeric argument and returns a number (integer, float, or double) of the same type as the
argument to the function. The `SQRT` function takes a numeric argument and returns a double.

The `MOD` function takes two integer arguments and returns an integer. The `SIZE` function returns an integer value, the
number of elements of the collection. If the collection is empty, the `SIZE` function evaluates to zero. Numeric
arguments to these functions may correspond to the numeric Java object types as well as the primitive numeric types.

##### JPQL Datetime Functions

```
functions_returning_datetime:= CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP
```

The datetime functions return the value of current date, time, and timestamp on the database server.

## JPQL `GROUP BY`, `HAVING`

The `GROUP BY` construct enables the aggregation of values according to a set of properties. The `HAVING` construct
enables conditions to be specified that further restrict the query result. **Such conditions are restrictions upon the
groups**. The syntax of the `GROUP BY` and `HAVING` clauses is as follows:

* `groupby_clause ::= GROUP BY groupby_item {, groupby_item}*`
* `groupby_item ::= single_valued_path_expression | identification_variable`
* `having_clause ::= HAVING conditional_expression`

If a query contains both a `WHERE` clause and a `GROUP BY` clause, the effect is that of first applying the where
clause, and then forming the groups and filtering them according to the `HAVING` clause. The `HAVING` clause causes
those groups to be retained that satisfy the condition of the `HAVING` clause. The requirements for the `SELECT` clause
when `GROUP BY` is used follow those of SQL: namely, **any item that appears in the `SELECT` clause (other than as an
argument to an aggregate function) must also appear in the `GROUP BY` clause**. In forming the groups, null values are
treated as the same for grouping purposes. Grouping by an entity is permitted. In this case, the entity must contain no
serialized state fields or lob-valued state fields. The `HAVING` clause must specify search conditions over the grouping
items or aggregate functions that apply to grouping items.

## JPQL `SELECT` Clause

The `SELECT` clause denotes the query result. More than one value may be returned from the `SELECT` clause of a query.
The `SELECT` clause may contain one or more of the following elements:

* a single range variable or identification variable that ranges over an entity abstract schema type,
* a single-valued path expression,
* an aggregate select expression,
* a constructor expression.

The `SELECT` clause has the following syntax:

* `select_clause ::= SELECT [DISTINCT] select_expression {, select_expression}*`
* `select_expression ::= single_valued_path_expression | aggregate_expression | identification_variable | OBJECT(identification_variable) | constructor_expression`
* `constructor_expression ::= NEW constructor_name ( constructor_item {, constructor_item}* )`
* `constructor_item ::= single_valued_path_expression | aggregate_expression`
* `aggregate_expression ::= { AVG | MAX | MIN | SUM } ([DISTINCT] state_field_path_expression) | COUNT ([DISTINCT] identification_variable | state_field_path_expression | single_valued_association_path_expression)`

For example:

```sql
SELECT pub.id, pub.revenue
FROM Publisher pub JOIN pub.magazines mag
WHERE mag.price > 5.00
```

> ⚠️ Note that the `SELECT` clause must be specified to return only single-valued expressions. The query below is
> therefore not valid
>
> ```
> SELECT mag.authors
> FROM Magazine AS mag
> ```
